    def decompress(self, archive_path, output_dir):
        # Создаем директорию для вывода, если она не существует
        os.makedirs(output_dir, exist_ok=True)

        magic_header = self.__iter_file(archive_path, len(MAGIC_HEADER))
        if magic_header != MAGIC_HEADER:
            raise ValueError("Invalid archive format")
        self.__iter_file(archive_path, len(NULL_BYTES))

        for block in self.__iter_file(archive_path):
            serialized_tree = self.__read_until_magic_cookie(archive_path, MAGIC_COOKIE_TREE)

        with open(archive_path, 'rb') as archive_file:


    def __decompress_data(self, archive_file, tree):
        decoded_data = ''
        current_code = ''
        while True:
            # Читаем данные из архива
            byte = archive_file.read(1)
            if not byte:
                break

            # Преобразуем байт в битовую строку
            byte_bits = bin(byte[0])[2:].rjust(8, '0')

            # Добавляем биты к текущему коду
            current_code += byte_bits

            # Пытаемся декодировать символ
            char = self.__decode_byte(current_code, tree)
            if char is not None:
                decoded_data += char
                current_code = ''

        return decoded_data

    @staticmethod
    def __decode_byte(byte, tree):
        # Декодируем байт, проверяя принадлежность к коду символа в дереве Хаффмана
        decoded_char = None
        node = tree.root
        for bit in byte:
            if bit == '0':
                node = node.left
            else:
                node = node.right

            if node.char is not None:
                decoded_char = node.char
                break

        return decoded_char

    def __read_until_magic_cookie(self, file_obj, magic_cookie, flag, block_size):
        if block_size is None:
            block_size = self.block_size

        data = b''
        while True:
            byte = file_obj.read(1)
            if not byte:
                break
            data += byte
            if len(data) <= block_size:
                # Если размер блока превышает максимальный размер, вернем данные до магического печенья
                if magic_cookie in data and flag:
                    return True, data[:data.index(magic_cookie)]
                else:
                    # Если магическое печенье не найдено, просто вернем весь текущий блок
                    return False, data
            if data.endswith(magic_cookie):
                return True, data[:-len(magic_cookie)]
        return False, data

    def __iter_file(self, file_obj, block_size=None):
        if block_size is None:
            block_size = self.block_size

        with open(file_obj, 'rb') as file:
            while True:
                block = file.read(block_size)
                if not block:
                    break
                yield block
